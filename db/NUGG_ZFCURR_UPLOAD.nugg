<?xml version="1.0" encoding="utf-16"?>
<nugget name="ZFCURR_UPLOAD">
 <PROG NAME="ZFCURR_UPLOAD" VARCL="X" SUBC="1" APPL="F" CNAM="CUTTINGP" CDAT="20101019" UNAM="CUTTINGP" UDAT="20101109" VERN="000697" RSTAT="K" RMAND="812" RLOAD="E" FIXPT="X" SDATE="20101109" STIME="105138" IDATE="20101109" ITIME="105138" UCCHECK="X">
  <textPool>
   <language SPRAS="E">
    <textElement ID="I" KEY="001" LENGTH="4 "/>
    <textElement ID="I" KEY="002" ENTRY="http://www.riksbank.se/templates/stat.aspx?id=16745" LENGTH="51 "/>
    <textElement ID="R" ENTRY="Currency file upload" LENGTH="20 "/>
    <textElement ID="S" KEY="P_DATE" ENTRY="        Exchange Rate date" LENGTH="26 "/>
    <textElement ID="S" KEY="P_DATE2" ENTRY="        Posting date" LENGTH="20 "/>
    <textElement ID="S" KEY="P_FILE" ENTRY="        Filename" LENGTH="27 "/>
    <textElement ID="S" KEY="P_PATH" ENTRY="        Pathname" LENGTH="16 "/>
   </language>
  </textPool>
  <source>*&amp;---------------------------------------------------------------------*
*&amp; Report  ZFCURR_UPLOAD
*&amp;
*&amp;---------------------------------------------------------------------*
*&amp;
* uploads the Valuta file from client
*&amp;
*&amp;---------------------------------------------------------------------*
REPORT  ZFCURR_UPLOAD MESSAGE-ID me.


* This program uploads a file of exchange rates into R3

* data file comes from:  http://www.riksbank.se/templates/stat.aspx?id=16745
* example filename:  DETALJERAT RESULTAT_2010-10-14_11.36.57.csv
* example records:
* Datum,Grupp,Serie,Värde
* 2010-10-01,Valutor mot svenska kronor,1 AUD,6.4900

TYPE-POOLS: truxs.
TABLES sscrfields.

* bapi data structures
data wa_return_bapi type BAPIRET2.
data it_return_bapi type table of BAPIRET2.
data l_bapi1093_0 like BAPI1093_0.

DATA: it_raw TYPE truxs_t_text_data.
DATA: wa_raw TYPE line of truxs_t_text_data.

* unique currencies
types:
  begin of t_unique_currency,
   currency type string,
  end of t_unique_currency.
data st_unique_currency type t_unique_currency.
data it_unique_currency type sorted table of t_unique_currency
        with unique key currency
               initial size 0.

TYPES:
BEGIN OF ty_exchange_rate,
  f_date type string,
  f_group type string,
  f_series type string,
  f_factor(10) type n,
  f_to_currency type string,
  f_from_currency type string,
  f_value type string,
  f_unit_rate type string,
END OF ty_exchange_rate.

data it_exchange_rate type TABLE OF ty_exchange_rate.
data it_exchange_rate_unfiltered type TABLE OF ty_exchange_rate.

data st_exchange_rate type ty_exchange_rate.
data g_count TYPE i.
data g_date like sy-datum.
data g_path type string.
data g_some_recs_have_no_rate type c value is initial.
data g_reset_date type c.

* supported currencies
constants: c_currencies(100) type C value &apos;DKK EUR GBP NOK PLN USD&apos;.  &quot; must be uppercase

*data HTML_CONTROL TYPE REF TO CL_GUI_HTML_VIEWER.
*DATA: DOCKING TYPE REF TO CL_GUI_DOCKING_CONTAINER.
*DATA: container TYPE REF TO cl_gui_custom_container.
data init.
DATA: ok_code LIKE sy-ucomm,
      save_ok LIKE sy-ucomm.

SELECTION-SCREEN BEGIN OF BLOCK frame1 WITH FRAME TITLE text-001.

SELECTION-SCREEN BEGIN OF LINE.
SELECTION-SCREEN PUSHBUTTON (20) w_button USER-COMMAND BUT1.
SELECTION-SCREEN END OF LINE.

SELECTION-SCREEN SKIP.

PARAMETERS p_path type filename memory ID ZC1.        &quot; path of file containing exchange rate data
PARAMETERS p_file type c length 128  Modif ID FIL .    &quot; read only field holding just the filename
PARAMETERS p_date LIKE SY-DATUM memory ID ZC3.         &quot; date to filter data
PARAMETERS p_date2 LIKE SY-DATUM  Modif ID DA2.        &quot; date to write the data to R3 with (next working day)

PARAMETERS DKK AS CHECKBOX MODIF ID DKK user-command DKK.
PARAMETERS EUR AS CHECKBOX MODIF ID EUR user-command EUR.
PARAMETERS GBP AS CHECKBOX MODIF ID GBP user-command GBP.
PARAMETERS NOK AS CHECKBOX MODIF ID NOK user-command NOK.
PARAMETERS PLN AS CHECKBOX MODIF ID PLN user-command PLN.
PARAMETERS USD AS CHECKBOX MODIF ID USD user-command USD.

SELECTION-SCREEN END OF BLOCK frame1.

*------------------------------------------------------*
initialization.

  w_button = &apos;Riksbanken&apos;.

* these objects must be created in a SAP package
  GET PARAMETER ID &apos;ZC1&apos; FIELD p_path.
  GET PARAMETER ID &apos;ZC3&apos; FIELD p_date.

  GET PARAMETER ID &apos;DKK&apos; FIELD DKK.
  GET PARAMETER ID &apos;EUR&apos; FIELD EUR.
  GET PARAMETER ID &apos;GBP&apos; FIELD GBP.
  GET PARAMETER ID &apos;NOK&apos; FIELD NOK.
  GET PARAMETER ID &apos;PLN&apos; FIELD PLN.
  GET PARAMETER ID &apos;USD&apos; FIELD USD.

  translate p_path to upper case.

*  clear p_path.
*  clear p_date.

  if p_date is initial.
    p_date = sy-datum.
  endif.

*
  g_path = p_path.
  g_date = p_date.

* calculate next working day
  perform sub_next_work_day using p_date p_date2.

*
  if p_path is not initial and p_date is not initial.
    perform sub_upload_file using &apos;X&apos;.
* process the data
    PERFORM sub_process_data.
    g_path = p_path.

    if not g_some_recs_have_no_rate is initial.
      MESSAGE I303 WITH &apos;Some records have no exchange rate&apos;(005).
    endif.
  endif.

*
  perform sub_path_to_file using p_path p_file.
  perform sub_pop_field_string using &apos;P_FILE&apos; p_file.


*------------------------------------------------------*

AT SELECTION-SCREEN  on p_date.
  if not p_date = g_date.
    g_date = p_date.

  endif.

AT SELECTION-SCREEN ON p_path.
  translate p_path to upper case.

  if not p_path = g_path.
    g_path = p_path.
    PERFORM sub_upload_file using &apos;&apos;.

    g_reset_date = &apos;X&apos;.

  endif.


*------------------------------------------------------*
AT SELECTION-SCREEN ON VALUE-REQUEST FOR p_path.
* display a dialogue window to select a input file
  perform sub_get_path CHANGING p_path.
  translate p_path to upper case.

  if not p_path = g_path.
    g_path = p_path.
    PERFORM sub_upload_file using &apos;&apos;.

    g_reset_date = &apos;X&apos;.

  endif.

*------------------------------------------------------*
AT SELECTION-SCREEN.

** Check authority
  AUTHORITY-CHECK OBJECT &apos;F_BKPF_BUK&apos;
        ID &apos;ACTVT&apos; FIELD &apos;01&apos;
        ID &apos;BUKRS&apos; FIELD &apos;6000&apos;.
  if sy-subrc ne 0.
    message a172(00) with sy-tcode.
  endif.

* Check if buttons have been
  if sscrfields-ucomm eq &apos;BUT1&apos;.
    CALL FUNCTION &apos;CALL_BROWSER&apos;
      EXPORTING
        NEW_WINDOW = &apos;X&apos;
        URL        = &apos;http://www.riksbank.se/templates/stat.aspx?id=16745&apos;.
    exit.
  endif.


* fill the file (read only) field
  perform sub_path_to_file using p_path p_file.
  perform sub_pop_field_string using &apos;P_FILE&apos; p_file.

* process the data
  PERFORM sub_process_data.

* check if there is any data
  if it_exchange_rate_unfiltered is initial.
    MESSAGE ID &apos;BD&apos; TYPE &apos;S&apos; NUMBER &apos;899&apos;
        WITH &apos;No exchange rate data in the file&apos;.
    exit.
  endif.


*------------------------------------------------------*
AT SELECTION-SCREEN OUTPUT.
* date
  if g_reset_date = &apos;X&apos;.
    clear g_reset_date.
    p_date = sy-datum.
  endif.
  perform sub_next_work_day using p_date p_date2.

* fill the file (read only) field
  perform sub_path_to_file using p_path p_file.
  perform sub_pop_field_string using &apos;P_FILE&apos; p_file.

  LOOP AT SCREEN.
* filename should be readonly
    IF SCREEN-group1 = &apos;FIL&apos;.
      SCREEN-input = &apos;0&apos;.
      MODIFY SCREEN.
      CONTINUE.
    ENDIF.
* next date should be readonly
    IF SCREEN-group1 = &apos;DA2&apos;.
      SCREEN-input = &apos;0&apos;.
      MODIFY SCREEN.
      CONTINUE.
    ENDIF.

* is the screen item a supported currency (and therefore a checkbox)
    search c_currencies for screen-name.
    if sy-subrc = 0.

* grey out currency checkboxes which have no corresponding data in the file
      read table it_unique_currency into st_unique_currency with key currency = SCREEN-name.
      if sy-subrc = 0.
        SCREEN-input = &apos;1&apos;.
      else.
        SCREEN-input = &apos;0&apos;.
      endif.
      MODIFY SCREEN.
      CONTINUE.
    endif.

  ENDLOOP.

* check if any non grey checkboxes are checked (otherwise flag an error ro the user)
  DATA itab TYPE table of string with header line.
  data num_currencies_checked type i value is initial.
  FIELD-SYMBOLS &lt;fs&gt; TYPE ANY.

  split c_currencies AT &apos; &apos; into table itab.

  loop at itab into itab.
    ASSIGN (itab) TO &lt;FS&gt;.
    if &lt;FS&gt; = &apos;X&apos;.
      num_currencies_checked = num_currencies_checked + 1.
    endif.
  endloop.

*
* check ifany currencies are checked
  if num_currencies_checked is initial.
    MESSAGE ID &apos;BD&apos; TYPE &apos;I&apos; NUMBER &apos;899&apos;
        WITH &apos;No currencies are checked&apos;.
  endif.

* check if there is any suitable data
  if it_exchange_rate is initial.
    MESSAGE ID &apos;BD&apos; TYPE &apos;S&apos; NUMBER &apos;899&apos;
        WITH &apos;No exchange rate data matches filter&apos;.
    exit.
  endif.

*------------------------------------------------------*
START-OF-SELECTION.


*------------------------------------------------------*
END-OF-SELECTION.

  PERFORM sub_write_data.
  PERFORM display_messages tables it_return_bapi.

* remember setup
  SET PARAMETER ID &apos;DKK&apos; FIELD DKK.
  SET PARAMETER ID &apos;EUR&apos; FIELD EUR.
  SET PARAMETER ID &apos;GBP&apos; FIELD GBP.
  SET PARAMETER ID &apos;NOK&apos; FIELD NOK.
  SET PARAMETER ID &apos;PLN&apos; FIELD PLN.
  SET PARAMETER ID &apos;USD&apos; FIELD USD.


*&amp;---------------------------------------------------------------------*
FORM sub_process_data.

  perform sub_parse_data.

  perform sub_proc_data.

ENDFORM.                    &quot;sub_process_data


*&amp;---------------------------------------------------------------------*
FORM sub_parse_data .
  DATA itab TYPE table of string with header line.
  DATA it_series TYPE table of string with header line.

*  data do_create_line type c.
*  FIELD-SYMBOLS &lt;fs&gt; TYPE ANY.

* lines from file look like this
* Datum,group,Serie,Värde
* 2010-10-01,Valutor mot svenska kronor,1 AUD,6.4900

  refresh it_exchange_rate_unfiltered.

  if it_raw is initial.
    MESSAGE W303 WITH &apos;File empty &apos;(005).
    exit.
  endif.

* loop over file data
  LOOP AT it_raw INTO wa_raw.

* search for currency lines (discard others)
    search wa_raw for &apos;Valutor mot svenska kronor&apos;.  &quot; ignore lines that are not exchange rate
    if sy-subrc = 4.
      continue.
    endif.

* check if records have suitable format
    refresh itab.
    split wa_raw AT &apos;,&apos; into table itab.
    DESCRIBE TABLE ITAB LINES g_count.
    if not ( g_count = 3 or g_count = 4 ).
      refresh it_raw.
      MESSAGE I303 WITH &apos;Currency records must contain 3 commas: &apos;(005) wa_raw.
      exit.
    endif.

* get date
    clear itab.
    READ TABLE itab index 1.
    concatenate itab+0(4) itab+5(2) itab+8(2) into st_exchange_rate-f_date.  &quot; convert 2010-10-01 to 20101001

* read group
    clear itab.
    READ TABLE itab index 2.
    move itab to st_exchange_rate-f_group.

* read series
    clear itab.
    READ TABLE itab index 3.
    move itab to st_exchange_rate-f_series.  &quot; split the series field into factor and currency
    split itab AT &apos; &apos; into table it_series.

    clear it_series.
    READ TABLE it_series INDEX 1.
    move it_series to st_exchange_rate-f_factor.
    clear it_series.
    READ TABLE it_series INDEX 2.
    translate it_series to upper case.      &quot; convert currency code to uppercase just in case
    move it_series to st_exchange_rate-f_from_currency.

* skip if not supported currency
    search c_currencies for st_exchange_rate-f_from_currency.
    if not sy-subrc = 0.
      continue.
    endif.

* read exchange rate value
    clear itab.
    move 0 to st_exchange_rate-f_value.
    READ TABLE itab index 4.
    if sy-subrc = 0.
      move itab to st_exchange_rate-f_value.
    endif.

    if st_exchange_rate-f_value = 0 or st_exchange_rate-f_factor = 0.
      st_exchange_rate-f_unit_rate = 0.
    else.
      move st_exchange_rate-f_value to st_exchange_rate-f_unit_rate.
      if not st_exchange_rate-f_factor = 1.
        st_exchange_rate-f_unit_rate = st_exchange_rate-f_value / st_exchange_rate-f_factor.
      endif.
    endif.

* add exchange rate to exchange rate list
    append st_exchange_rate to it_exchange_rate_unfiltered.

  ENDLOOP.

ENDFORM.                    &quot;sub_parse_data


*&amp;---------------------------------------------------------------------*
*&amp;      Form  sub_proc_data
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM sub_proc_data .
  DATA itab TYPE table of string with header line.
  DATA it_series TYPE table of string with header line.
  data do_create_line type c.
  FIELD-SYMBOLS &lt;fs&gt; TYPE ANY.

* lines from file look like this
* Datum,group,Serie,Värde
* 2010-10-01,Valutor mot svenska kronor,1 AUD,6.4900

* add this currency to the unique currency list
  refresh it_unique_currency.
  refresh it_exchange_rate.
  clear g_some_recs_have_no_rate.

* loop over file data
  LOOP AT it_exchange_rate_unfiltered INTO st_exchange_rate.

* filter dates
    if not st_exchange_rate-f_date = p_date.
      continue.
    endif.

* skip record and warn user if currency has no exchange rate
    if st_exchange_rate-f_unit_rate = 0.
      g_some_recs_have_no_rate = &apos;X&apos;.
      continue.
    endif.

* add this currency to the unique currency list
    move st_exchange_rate-f_from_currency to st_unique_currency-currency.
    insert st_unique_currency into table it_unique_currency.     &quot; duplicate currencies are discarded since table key is unique

* skip this currency record if checkbox not selected
    clear do_create_line.
    search c_currencies for st_exchange_rate-f_from_currency.
    if sy-subrc = 0.
      ASSIGN (st_exchange_rate-f_from_currency) TO &lt;FS&gt;.
      if &lt;FS&gt; = &apos;X&apos;.
        do_create_line = &apos;X&apos;.
      endif.
    endif.

    if do_create_line is initial.
      continue.
    endif.

* add exchange rate to exchange rate list
    append st_exchange_rate to it_exchange_rate.

  ENDLOOP.

ENDFORM.                    &quot;sub_proc_data


*&amp;---------------------------------------------------------------------*
FORM sub_next_work_day using p_date p_next_date.

  data l_date like sy-datum.
  data l_next_date like sy-datum.
  data l_day like SCAL-INDICATOR.

  l_date = p_date.
  p_next_date = &apos;&apos;.

  do 100 times.    &quot; limit the max nmber of iterations

    call function &apos;FIMA_DATE_CREATE&apos;
      EXPORTING
        i_date                  = l_date
        i_calendar_days         = 1
        i_set_last_day_of_month = &apos;&apos;
      IMPORTING
        e_date                  = l_next_date.

    if sy-subrc &lt;&gt; 0.
    endif.

    CALL FUNCTION &apos;DATE_COMPUTE_DAY&apos;
      EXPORTING
        DATE   = l_next_date
      IMPORTING
        DAY    = l_day
      EXCEPTIONS
        OTHERS = 8.

    if l_day &lt; 6.    &quot; if weekday
      p_next_date = l_next_date.
      exit.
    endif.

    l_date = l_next_date.
  enddo.

endform.                    &quot;sub_next_work_day


*&amp;---------------------------------------------------------------------*
FORM sub_upload_file using ignore_error .
* Call Function module to upload file from PC

  DATA: lv_path TYPE string.

  check not p_path is initial.
  refresh it_raw.

  lv_path = p_path.    &quot; type conversion to string

  CALL FUNCTION &apos;GUI_UPLOAD&apos;
    EXPORTING
      filename                = lv_path
      filetype                = &apos;ASC&apos;
      has_field_separator     = &apos;,&apos;
    TABLES
      data_tab                = it_raw
    EXCEPTIONS
      file_open_error         = 1
      file_read_error         = 2
      no_batch                = 3
      gui_refuse_filetransfer = 4
      invalid_type            = 5
      no_authority            = 6
      unknown_error           = 7
      bad_data_format         = 8
      header_not_allowed      = 9
      separator_not_allowed   = 10
      header_too_long         = 11
      unknown_dp_error        = 12
      access_denied           = 13
      dp_out_of_memory        = 14
      disk_full               = 15
      dp_timeout              = 16
      OTHERS                  = 17.

  if ignore_error = &apos;X&apos;.
    IF sy-subrc &lt;&gt; 0.
*      MESSAGE ID sy-msgid TYPE &apos;I&apos; NUMBER sy-msgno
*              WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    ENDIF.
    exit.
  endif.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
  ENDIF.

ENDFORM.                    &quot;sub_upload_file


*&amp;---------------------------------------------------------------------*


*&amp;---------------------------------------------------------------------*
FORM sub_write_data .
  data l_s type string.
  data cnt(4) type n.

  data it_unique_currency_created type sorted table of t_unique_currency  &quot; currencies that exchange rates are created for
          with unique key currency
                 initial size 0.

* check if there is anything to do
  if it_exchange_rate is initial.
    exit.
  endif.

  cnt = 0.
  refresh it_return_bapi.

  loop at it_exchange_rate into st_exchange_rate.
    cnt = cnt + 1.
* concatenate cnt &apos; - &apos; st_exchange_rate-f_date &apos;-&apos; st_exchange_rate-f_group &apos;-&apos; st_exchange_rate-f_series &apos;-&apos; st_exchange_rate-f_value st_exchange_rate-f_factor &apos;-&apos; st_exchange_rate-f_from_currency &apos;-&apos; st_exchange_rate-f_unit_rate into l_s.
* WRITE:/ l_s.
    st_exchange_rate-f_to_currency = &apos;SEK&apos;.
    perform sub_exchange_rate_create using st_exchange_rate.

* remebmber that an exchange rate has been created for this currency. (Used for creating additional EUR exchange rates below)
    move st_exchange_rate-f_from_currency to st_unique_currency-currency.
    insert st_unique_currency into table it_unique_currency_created.      &quot; duplicate currencies are discarded since table key is unique
  endloop.

* Create the additional &quot;to EUR&quot; exchange rates

* check if there is a EUR to SEK rate in the file data. If there is not then we cannot proceed

  data st_exchange_rate_eur type ty_exchange_rate.
  clear st_exchange_rate_eur.

  loop at it_exchange_rate into st_exchange_rate.
    if st_exchange_rate-f_from_currency = &apos;EUR&apos;.
      st_exchange_rate_eur = st_exchange_rate.
    endif.
  endloop.

* check if we can proceed
  if st_exchange_rate_eur is initial.
    exit.
  endif.

*
  data st_exchange_rate2 type ty_exchange_rate.

* for each unique created exchange rate currency
  loop at it_unique_currency_created into st_unique_currency.
    if st_unique_currency-currency = &apos;EUR&apos;.          &quot; ignore EUR otherwise would be converting EUR to EUR
      continue.
    endif.

* find the currency exchange rate
    loop at it_exchange_rate into st_exchange_rate.

      if st_exchange_rate-f_from_currency = st_unique_currency-currency.
        st_exchange_rate2 = st_exchange_rate.
        st_exchange_rate2-f_to_currency = &apos;EUR&apos;.
        st_exchange_rate2-f_unit_rate = st_exchange_rate2-f_unit_rate / st_exchange_rate2-f_unit_rate.  &quot; DKK&gt;EUR = DKK&gt;SEK * ( 1 / EUR&gt;SEK )
        perform sub_exchange_rate_create using st_exchange_rate2.
        exit.
      endif.
*
    endloop.
  endloop.

ENDFORM.                    &quot;sub_write_data



*&amp;---------------------------------------------------------------------*
*&amp;      Form  sub_exchange_rate_create
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
FORM sub_exchange_rate_create using p_exchange_rate type ty_exchange_rate.

  l_bapi1093_0-rate_type = &apos;M&apos;.
  l_bapi1093_0-from_curr = p_exchange_rate-f_from_currency.
  l_bapi1093_0-to_currncy = p_exchange_rate-f_to_currency.
  l_bapi1093_0-valid_from = p_exchange_rate-f_date.
  l_bapi1093_0-exch_rate = p_exchange_rate-f_unit_rate .  &quot; Direct Quoted Exchange Rate
  l_bapi1093_0-from_factor = 1.      &quot; Ratio for the &quot;From&quot; Currency Units
  l_bapi1093_0-to_factor = 1.     &quot; Ratio for the &quot;To&quot; Currency Units
*l_bapi1093_0-exch_rate_v = .       &quot; Indirect Quoted Exchange Rate
*l_bapi1093_0-from_factor_v = .     &quot; Ratio for the &quot;From&quot; Currency Units
*l_bapi1093_0-to_factor_v = .       &quot; Ratio for the &quot;To&quot; Currency Units

  clear wa_return_bapi.

  CALL FUNCTION &apos;BAPI_EXCHANGERATE_CREATE&apos; &quot;Addition of Entry in Table of Exchange Rates
    EXPORTING
      exch_rate = l_bapi1093_0    &quot; Exchange Rate To Be Written
*   upd_allow = SPACE           &quot; bapi1093_2-upd_allow  &apos;X&apos; = Update of Existing Exchange Rate is Also Permitted
*   chg_fixed = SPACE           &quot; bapi1093_2-chg_fixed  &apos;X&apos; = Permit Changes to Fixed Exchange Rate
*   dev_allow = &apos;000&apos;           &quot; bapi1093_2-dev_allow  Permitted Difference to Old Exchange Rate as Percentage
    IMPORTING
      return = wa_return_bapi.

  if wa_return_bapi is not initial.
    concatenate p_exchange_rate-f_from_currency &apos;-&gt;&apos; p_exchange_rate-f_to_currency into wa_return_bapi-message_v1.
    append wa_return_bapi to it_return_bapi.
  endif.

  commit work.

ENDFORM.                    &quot;sub_exchange_rate_create


*&amp;---------------------------------------------------------------------*
*&amp;      Form  display_messages
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;P_ITAB_RETURN  text
*----------------------------------------------------------------------*
FORM display_messages  tables p_itab_return type BAPIRET2_T.

  DATA: ls_msg TYPE bapiret2.

  CALL FUNCTION &apos;MESSAGES_INITIALIZE&apos;.

  LOOP AT p_itab_return INTO ls_msg.
    CALL FUNCTION &apos;MESSAGE_STORE&apos;
      EXPORTING
        arbgb                  = ls_msg-id
        msgty                  = ls_msg-type
        msgv1                  = ls_msg-message_v1
        msgv2                  = ls_msg-message_v2
        msgv3                  = ls_msg-message_v3
        msgv4                  = ls_msg-message_v4
        txtnr                  = ls_msg-number
      EXCEPTIONS
        message_type_not_valid = 1
        not_active             = 2
        OTHERS                 = 3.
  ENDLOOP.

  CALL FUNCTION &apos;MESSAGES_STOP&apos;
    EXCEPTIONS
      a_message = 1
      e_message = 2
      i_message = 3
      w_message = 4
      OTHERS    = 5.

  CALL FUNCTION &apos;MESSAGES_SHOW&apos;
    EXPORTING
      show_linno         = &apos; &apos;
    EXCEPTIONS
      inconsistent_range = 1
      no_messages        = 2
      OTHERS             = 3.

ENDFORM.                    &quot; DISPLAY_MESSAGES



*&amp;---------------------------------------------------------------------*
*&amp;      Form  sub_get_path
*&amp;---------------------------------------------------------------------*
*       text
*----------------------------------------------------------------------*
*      --&gt;PATH   text
*----------------------------------------------------------------------*
FORM sub_get_path CHANGING path.

  DATA: lt_filetable TYPE filetable,
        lv_fname(50) TYPE c,
        lv_fext(40) TYPE c.

* Function module to show File open Dialog
  CALL METHOD cl_gui_frontend_services=&gt;file_open_dialog
    EXPORTING
      window_title            = &apos;Select Text File Data&apos;
*      default_extension       = &apos;.csv&apos;                  &quot; only used for saving
      file_filter             = &apos;CSV Files (*.csv)|*.csv|&apos;
      multiselection          = abap_false
    CHANGING
      file_table              = lt_filetable
      rc                      = g_count
    EXCEPTIONS
      file_open_dialog_failed = 1
      cntl_error              = 2
      error_no_gui            = 3
      not_supported_by_gui    = 4
      OTHERS                  = 5.

  IF sy-subrc &lt;&gt; 0.
    MESSAGE ID sy-msgid TYPE &apos;S&apos; NUMBER sy-msgno
               DISPLAY LIKE &apos;E&apos;
               WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
    EXIT.
  ENDIF.

* Number of selected filed must be equal to one.
  CHECK g_count = 1.

* Access selected file
  DATA ls_file TYPE file_table.

  READ TABLE lt_filetable INTO ls_file INDEX 1.
  CHECK sy-subrc = 0.

  DATA itab TYPE table of string.

  SPLIT ls_file-filename AT &apos;.&apos; INTO TABLE itab.
  DESCRIBE TABLE ITAB LINES g_count.

  read table ITAB index g_count into lv_fext.
  translate lv_fext to lower case.

  IF lv_fext NE &apos;csv&apos;.
    MESSAGE &apos;Wrong File Type. Must be .csv&apos; TYPE &apos;I&apos;.
  ENDIF.

  path = ls_file-filename.
ENDFORM.                    &quot;sub_get_path


*&amp;---------------------------------------------------------------------*
form sub_path_to_file using p_path p_file.

  data lit_string TYPE table of string.
  data l_count TYPE i.
  data l_string type string.

* get the filename
  SPLIT p_path AT &apos;\&apos; INTO TABLE lit_string.
  DESCRIBE TABLE lit_string LINES l_count.
  read table lit_string index l_count into p_file.

endform.                    &quot;sub_path_to_file


*&amp;---------------------------------------------------------------------*
FORM sub_pop_field_string using pa_field pa_string.
  DATA: l_i_dynpfields  TYPE STANDARD TABLE OF dynpread INITIAL SIZE 0,
        l_wa_dynpfields TYPE dynpread.

  l_wa_dynpfields-fieldname = pa_field.
  l_wa_dynpfields-fieldvalue = pa_string.
  translate l_wa_dynpfields-fieldname to upper case.
  APPEND l_wa_dynpfields TO l_i_dynpfields.

*  CALL FUNCTION &apos;DYNP_VALUES_UPDATE&apos;
*    EXPORTING
*      dyname               = SY-CPROG
**      dyname               = sy-repid
*      dynumb               = sy-dynnr
*    TABLES
*      dynpfields           = l_i_dynpfields
*    EXCEPTIONS
*      invalid_abapworkarea = 1
*      invalid_dynprofield  = 2
*      invalid_dynproname   = 3
*      invalid_dynpronummer = 4
*      invalid_request      = 5
*      no_fielddescription  = 6
*      undefind_error       = 7
*      OTHERS               = 8.
*  IF sy-subrc &lt;&gt; 0.
*    MESSAGE ID sy-msgid TYPE sy-msgty NUMBER sy-msgno
*            WITH sy-msgv1 sy-msgv2 sy-msgv3 sy-msgv4.
*  ENDIF.


* try 2
  DATA :
  t_dynpread TYPE TABLE OF dynpread,
  x_dynpread TYPE dynpread.

  x_dynpread-fieldname = pa_field.
  x_dynpread-fieldvalue = pa_string.
  translate x_dynpread-fieldname to upper case.
  APPEND x_dynpread TO t_dynpread.

  CALL FUNCTION &apos;DYNP_UPDATE_FIELDS&apos;
    EXPORTING
      dyname               = sy-repid
      dynumb               = sy-dynnr
      request              = &apos;A&apos;
    TABLES
      dynpfields           = t_dynpread
    EXCEPTIONS
      invalid_abapworkarea = 1
      invalid_dynprofield  = 2
      invalid_dynproname   = 3
      invalid_dynpronummer = 4
      invalid_request      = 5
      no_fielddescription  = 6
      undefind_error       = 7
      OTHERS               = 8.
  IF sy-subrc = 0.
* MESSAGE ID SY-MSGID TYPE SY-MSGTY NUMBER SY-MSGNO
* WITH SY-MSGV1 SY-MSGV2 SY-MSGV3 SY-MSGV4.
  ENDIF.

ENDFORM.                    &quot;sub_pop_field_string




*DATE_COMPUTE_DAY Returns a number indicating what day of the week the date falls on. Monday is returned as a 1, Tuesday as 2, etc.
*DATE_IN_FUTURE Calculate a date N days in the future.
*
*RP_CALC_DATE_IN_INTERVAL Add days/months to a date
*
*RP_CALC_DATE_IN_INTERVAL Add/subtract years/months/days from a date
*
*SD_DATETIME_DIFFERENCE Give the difference in Days and Time for 2 dates
*MONTH_PLUS_DETERMINE Add or subtract months from a date. To subtract a month, enter a negative value for the &apos;months&apos; parameter.
*

*data: ld_date                 like scal-datum  default sy-datum,
*      lc_holiday_cal_id       like scal-hcalid default &apos;CA&apos;, &quot; example
*      ltab_holiday_attributes like thol occurs 0 with header line,
*      lc_holiday_found        like scal-indicator.
*
*CALL FUNCTION &apos;HOLIDAY_CHECK_AND_GET_INFO&apos;
*  EXPORTING
*    date                               = ld_date &quot;input date
*    holiday_calendar_id                = lc_holiday_cal_id   &quot;this u need to give as input
*    WITH_HOLIDAY_ATTRIBUTES            = &apos;X&apos;
*  IMPORTING
*    HOLIDAY_FOUND                      = lc_holiday_found
*  tables
*    holiday_attributes                 = ltab_holiday_attributes
*  EXCEPTIONS
*    CALENDAR_BUFFER_NOT_LOADABLE       = 1
*    DATE_AFTER_RANGE                   = 2
*    DATE_BEFORE_RANGE                  = 3
*    DATE_INVALID                       = 4
*    HOLIDAY_CALENDAR_ID_MISSING        = 5
*    HOLIDAY_CALENDAR_NOT_FOUND         = 6
*    OTHERS                             = 7.
*
*if sy-subrc = 0 and
*   lc_holiday_found = &apos;X&apos;.
*  write: / ld_date, &apos;is a holiday&apos;.
*else.
*  write: / ld_date, &apos;is not a holiday, or there was an error calling the function&apos;.
*endif.</source>
 </PROG>
</nugget>
